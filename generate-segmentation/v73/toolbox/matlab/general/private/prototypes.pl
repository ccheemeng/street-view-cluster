#!/usr/local/bin/perl -w
# Parse a C/C++ header file and build up three data structures: the first
# is a list of the prototypes defined in the header file; the second is 
# a list of the structures used in those prototypes.  The third is a list of the 
# typedef statements that are defined in the file
#
# The header file must have already been processed by the pre-processor if it contains 
# preprocessor code.
#
# Options supported:
# 
#
# command line:
# prototypes [options] [-outfile=name] input.i  [optional headers to find protoypes in]  
#
# Copyright 2002-2005 The MathWorks, Inc.
# $Revision: 1.1.6.13 $ $Date: 2005/06/30 17:20:33 $

# file general information:
# ParseXXXXX functions do not modify known state and may be called recursively
# ProcessXXXXX functions add information to global type tables

$FileRev='$Revision: 1.1.6.13 $';
$FileRev=~/[\d.]+/;
$FileRev=$&;
$cmdline=join ' ', @ARGV;
parsArgs(debug=>0,outfile=>'-',calltype=>'cdecl',allsrc=>0);
$outfile=$options{outfile};
open OUTFILE,">$outfile" or die "Can not open output file $outfile because $!";

open INFILE ,"<$ARGV[0]" or die "Can not open file $ARGV[0] because $!";
@keywords= sort qw(auto double int struct break else long switch case enum register 
              typedef char extern return union const float short unsigned continue
              for signed void default goto sizeof volatile do if static while);
#create a hash of all C keywords
foreach (@keywords) {
$keywords{$_}=undef;
} 

%baseTypes = qw(int8_t int8 int8_T int8 char int8 short int16 int int32 long int32 __int64 int64 longlong int64 shortint int16 longint int32); 
%otherTypes = qw(bool bool struct struct unsigned uint32 float single double double enum int32);
%windowsTypes = qw(DWORD uint32 UINT uint32);

#setting typeOverrides to 1 for a type prevents an error if a header
#file has a conflicting typedef.  Use to replace a c typedef with a custom
#or other compatible type in MATLAB 
$typeOverrides{'bool'}=1;  #cpp has bool native type c has typedef


for (keys %baseTypes) {
    my $bt=$baseTypes{$_};
    $types{$_}=$bt;
    $types{'unsigned' . $_ }='u'.$bt ;    
}
for (keys %otherTypes) {
	$types{$_}=$otherTypes{$_};
}
#if on windows add windows types
for (keys %windowsTypes) {
	$types{$_}=$windowsTypes{$_};
	$typeOverrides{$_}=1;
}

for (keys %types) {
   my $bt=$types{$_};
    $types{$_ . 'Ptr'}=$bt . 'Ptr';
 }


#fixup special types
$types{'int64_T'}='int64';
$types{'uint64_T'}='uint64';
$types{'charPtr'}='cstring';
$types{'charPtrPtr'}='stringPtrPtr';
$types{'mxArrayPtr'}='MATLAB array';
$mxArrayPtrPtr='MATLAB array Ptr';
$types{'mxArrayPtrPtr'}=$mxArrayPtrPtr;
$types{'void'}='void';  # for void functions
$types{'voidPtr'}='voidPtr';  
$types{'voidPtrPtr'}='voidPtrPtr';  
 
$types{'...'}='vararg';
#    An optional typefile may be specified the format of which is "ctype matlabtype" 
if (exists $options{typefile}) {
    open TYPEFILE,"<$options{typefile}" or die "Can not open typefile $options{typefile} because $!";
    while (<TYPEFILE>) {
        chomp $_;
        ($ctype,$mtype)=split(/\s+/,$_);
        if (defined( $ctype) and defined( $mtype)) {
            print "Adding user type $ctype to be $mtype\n"  if ($options{debug} eq 'types');
            $types{$ctype}=$mtype; 
            $typeOverrides{$ctype}=1;
        }
    }
    close TYPEFILE;
}

if (exists $options{thunkfile}) {
    my @mltypes=qw(int8 int16 int32);
    my @ctypes=qw(char short long);
    my $i;
    open THUNKFILE,"> $options{thunkfile}" or die "Can not open C output file $options{thunkfile} because $!";
    print THUNKFILE "/* C thunk file for functions in $outfile generated on " , scalar localtime , ". */\n\n";
    for ($i=0;$i<@ctypes;$i++) {
        print  THUNKFILE "typedef $ctypes[$i] $mltypes[$i];\n";
        print  THUNKFILE "typedef unsigned $ctypes[$i] u$mltypes[$i];\n";
        push @mltypes,"u$mltypes[$i]";
    } 
    print  THUNKFILE "typedef void * voidPtr;\n";
    print  THUNKFILE "typedef char * string;\n";
    push @mltypes,qw(string voidPtr);
    foreach (@mltypes) {
        $MatlabType{$_}=undef;
    }
}

$functionCount=1; #matlab starts at one
$structCount=1;
$inSrcFile=1;  #if no line statements then all code counts
$packing=8;
for (@ARGV) {
    s/([\w\s]+)\.[\w\s]*$/$1/;
    push @SrcFiles,quotemeta($_);
}
$SrcFiles=join '|',@SrcFiles;
print "SrcFiles is $SrcFiles.\n" if $options{debug};
$str='';
if ( $outfile=~/([^\\]+)\.[^\\]+$/ ) {
    $writeingfunc=1;
    $capname=uc($1); 
    print OUTFILE "function [methodinfo,structs,enuminfo]=$1;\n";
    $hfile=$ARGV[0];
    $hfile=~s/\.i/.h/;
    print OUTFILE "%$capname Create structures to define interfaces found in '$hfile'.\n\n" ;
    print OUTFILE "%This function was generated by loadlibrary.m parser version $FileRev on " ,scalar localtime ,"\n";
    print OUTFILE "%loadlibary options:'$options{loadlibrarycmd}' \n" if exists $options{'loadlibrarycmd'} ; 
    print OUTFILE "%perl options:'$cmdline'\n"; 
    print OUTFILE "ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.\n";
    print OUTFILE "fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);\n";
    print OUTFILE "structs=[];enuminfo=[];fcnNum=1;\n";
} else {
       $writeingfunc=0;
    }
$srcFile='';
while (<INFILE>)
{
    # Ignore pre-processor directives and blank lines
    chomp;
    next if  /^\s*$/; #Just skip white space lines
    if (/^#/) {
     #print "skiping $_";
     if (/^#line\s+\d+\s+\"(.*)\"/ || /^# \d+ \"(.*)\" \d+$/ ) {
        if ($1 ne $srcFile) {
            $srcFile=$1;
            $inSrcFile=/\b$SrcFiles\b/ if !$options{allsrc};
            
            print "dumping ************* \n'$str'\n *****because of include file change\n" if ($options{debug} && $str ne '') ;  
            $str='' ;  #clear out string for safty
            print "inSrcFile is $inSrcFile for $_\n" if ($options{debug} eq 'srcfile');
     	}
     	/^#line\s+(\d+)/ || /^# \d+ \".*\" (\d+)$/;
        $srcLine=$.-$1;
     }
     if (/^#\s*pragma\s+pack\s+/) {
         if ($'=~/^\(\s*(\d+)\s*\)/) {
            $packing=$1;
         } elsif ($'=~/^\(\s*push\s*,\s*(\d+)\s*\)/) {
            push(@packing,$packing);
            $packing=$1;
         } elsif ($'=~/^pop/) {
            $packing=pop(@packing);
         } else {
            DumpInfo( "Unsupported packing pragma '$_'");
         }
     }
     next; 
    }
    #split up a line on simicolens because this script only can deal with one statement at a time
    @statements=split /;/ ;
    @statements=map { $_ . ';'} @statements; #put back the semi's
    $statements[-1]=substr($statements[-1],0,-1) unless /;$/;  #remove the last semi if there was not one there

    foreach $st (@statements) 
    {
        
    $str = $str . ' ' . $st;    #space is needed becase line end is a delimiter
    print "str '$str' is blank\n" if (length($str)<2 && $options{debug});
    
    #check for matched parens
    my $t=$str;
    if ($t=~ tr/{([// != $t=~tr/})]//) {
        #print "odd parans found appending str is '$str'\n";
        next; 
    }

    #make sure all boundries are single space delimited
    $str=join(' ',grep(length>0,split(/\b|\s+/,$str)));
    #$str2=~ s/\s+|\b/ /g; #doubles some spaces
    # Collapse multiple whitespace to a single space character
    #$str =~ s/\s+/ /g;

    #pull Windows __declspec(dllimport) and export they confuse other processing
    $str=~s/__declspec\s?\(.*?\)//;


    if (!($st=~/;\s*$/)) { # line does not end in semi just concat it
        #print "Appending $_\n";
        next if ($str=~/^ ?(typedef|struct|enum) /);
        if ($str=~/\} ?$/) {
             print "**** found function '$str'\n" if $options{debug};;
             $str='';
             next;
        }  
        #print "**** found no semi in '$str'\n" if $options{debug};
        next;
    }

 
    # Build an association list of typedefs. The goal is to be able to
    # resolve a defined type into the native C/++ type underlying it
    if ($str =~/typedef /) { 
        if ($str =~/typedef (struct|enum) / ) {  # if it is an enum or struct
            my $type=$1;
            my $tstr=$';
            if ($tstr=~/^\w*\s?\{[^}]*$/) {# append more data
                print "**** found partial $1 in $str\n" if $options{debug};
                next;
            }
            if ($tstr =~/^\s?(\w+) ([^;{}]+);/) {  # found an enum or struct typedef with no declaration
                    my $Name=$1;
                    my $Types=$2;
                    $Name=MakeMatlabVar($Name);
                    ProcessTypedef($Name,$Types);
                    $str='';
                    next;
            } 
            if ($type eq 'enum') { #found an enum
                my $enumName;
                my $enumTypes;
                my $enumDefines;
                
                if ($tstr =~ /^(\w+)\s?\{(.*)\}([^;]*)/) { #It has a name
                    $enumName=$1;
                    $enumDefines=$2;
                    $enumTypes=$3;
                } elsif ($tstr =~/^\s?\{(.*)\} ?(\w+) ?,?([^;]*)/) { # it is nameless
                    $enumDefines=$1;
                    $enumName=$2;
                    $enumTypes=$3;
                } elsif ($tstr =~/^\s?\{(.*)\}\s?;/) { # typedef enum {...};
                    $enumDefines=$1;
                    $enumName=undef;
                    $enumTypes=undef;
                } else {
                    print "error matching enum typedef in '$str' trying more data.\n" if $options{debug};
                    next;
                }
                if ($enumDefines=~/^\s*$/) { #no actual enum values
        	    AddType($enumName,'int32');
        	}else {
        	    if (defined $enumName) {
                        AddType($enumName,MakeMatlabVar($enumName));
                        $enumName=MakeMatlabVar($enumName);
                        ProcessTypedef($enumName,$enumTypes) if defined $enumTypes;
                    } else {
                        $enumName='dummyEnumName';
                    }
                    ProcessEnum($enumName,$enumDefines);
                }
                $str='';
                next;        
            }
    
            if ($str =~/typedef struct (\w+)\s?\{(.*)\}\s*([^;]*)/ ) {# we got a struct 
                print "Found struct $1 to be $3.\n" if $options{debug} eq 'structs';
                ProcessStruct($1,$2,$3);
                $str='';
                next;
            }
    
            if ($str =~/typedef struct\s?\{(.*)\}\s*(\w+) ?,?([^;]*)/ ) {# we got nameless a struct
                print "Found nameless struct to be $2.\n" if $options{debug} eq 'structs';
                if (exists $types{$2})
                {
                    DumpError("Error type '$2' is multiply defined.\n"); 
                }
                my $typedefs=$3;
                my $sname=$2;
                ProcessStruct($sname,$1,$typedefs);
                $str='';
                next;
            }
            # error ?
            print "Error matching typedef (enum|struct) in '$str'.\n" if $options{debug};

        } #end of typedef (enum|struct)

        if ($str =~/\)\s*[;,]/) {
            print "found function prototype typedef '$str'.\n" if $options{debug};
            #try to find the name
            if ( $str =~/typedef .*?\(.*\b(\w+) \) ?\(.*\) ?[,;]/ 
                 || $str =~/typedef .*\b(\w+) ?\(.*\) ?[,;]/  ) {
                AddType($1,'FcnPtr'); # if !exists $keywords{$1};
            }
            $str='';
            next;
        }
        
        if ($str =~/typedef([^;,*]+)([*\s]+\w+.*);/) #one line typedef
        {
            $typedef = $1;
            $newtypes = $2;
            $newtypes=arrayToPtr($newtypes);
            if ($typedef =~ /^ (struct|enum)\s*\{/) {
                DumpError("Punted typedef because found '$1'.");
                next;
            }            
            # Chop off leading and trailing spaces
            $newtypes =~ s/^[ \t]+//g;
            $newtypes =~ s/[ \t]+$//g;
            $typedef =~ s/^[ \t]+//g;
            $typedef =~ s/[ \t]+$//g;
            print "defining '$newtypes' to be '$typedef'\n" if $options{debug} eq 'types';
            ProcessTypedef($typedef,$newtypes);
            $str='';
            next;
        }
    } elsif ($str =~/^\s*enum\s*(\w+)\s*\{(.*?)\}\s*;/) {#found a naked enum
    	if ($2=~/^\s*$/) {#no actual enum values
    	    AddType($1,'int32');
    	}else {
#            ProcessTypedef('enum','enum'. $1);
            AddType($1,MakeMatlabVar($1));
            ProcessEnum($1,$2);
        }
        $str='';
    } elsif ($str =~/^\s*struct (\w+)\s*\{(.*?)\}\s*;/) {#found a naked struct
        ProcessStruct($1,$2,'');
        $str='';
    } elsif ($str =~/^\s*struct (\w+)\s*;/) {#found a struct forward declaration
        ProcessStruct($1,'','');
        $str='';
    }elsif ($str =~/^[^{}();]*;\s*/) {
        #basic data declaration drop it
        print "found simple data declaration of $str\n" if $options{debug};
        $str='';
        next;
    } elsif ($str =~/^.*\w+ ?; ?/) {
        #advanced (one with parens /casting) data declaration drop it
        print "found advanced data declaration of $str\n" if $options{debug};
        $str='';
        next;
    } elsif ($str =~/^.*?\( ?\* ?(\w+)\) ?\(.*\) ?; ?/) {
        #function pointer data declaration drop it
        print "found function pointer data declaration of $str\n" if $options{debug};

        $str='';
        next;
    } elsif ($str =~ /^ ?(.*?)(\w+) ?\((.*?)\) ?;/) {
    # Function prototype. Emit a line of MATLAB code to build up the function
	if (!$inSrcFile) {
                print "Function '$2' skipped because srcfile is '$srcFile'.\n" if $options{debug} eq 'srcfile';
		$str = "";
		next;
	}
        $ftype= $rtype = $1;
        $name = $2;
        $pstr = $3;
        if ( $pstr=~/\(/ ) {
            # supporting this will require rewriting the parameter parser
            print "Function $name skipped because '$pstr' contains function pointer arguments.\n" if $options{debug};
            $str="";
            next;
        } 
    	$calltype=$options{calltype};
        #pull any 'extern' statements
        if ($rtype =~ s/\bextern\b//g) {
            $rtype =~ s/\"\s?C\s?\"//; # did it have extern "C"?  spaces were added when word delimiters were spaced
        }
        
        #pull any 'stdcall' statements. WINAPI is present to help reduce the need for windows.h 
        if ($rtype =~ s/\b(_*stdcall|WINAPI)\b//g) {
            $calltype='stdcall';
        }

        if ($rtype =~ s/\b_*cdecl\b//g) {
            $calltype='cdecl';
        }
    		
        $lhs=GetUddType($rtype);
        print "function '$name' type is $ftype striped is '$rtype' translated to $lhs\n" if ($options{debug} eq 'functions');

        #$pstr=~s/(\w+)\s*\[\]/\*$1/g; # change var[] to *var
        @parameters = split(/,/, $pstr);
        # Print out the parameter list 
        my $newparam;
        my $oldparse;
        foreach $parameter (@parameters)
        {
            $newparam=ParseType($parameter);
            #$newname=defined $NewName ? $NewName : '';
            if ($options{'debug'} ) {
                $oldparse=OldParseParam($parameter);
                print "Type difference from $parameter old p='$oldparse', new p='$newparam'\n" if ($oldparse ne $newparam);
            }
            $parameter=$newparam;
        }
        #now print out prototype to the file
        print OUTFILE "% $str \n";
        #is it a mex style function?
        if (@parameters==4 && $lhs eq 'void' && $parameters[0] eq 'int32' && $parameters[2] eq 'int32'
            && $parameters[1] eq $mxArrayPtrPtr && $parameters[3] eq $mxArrayPtrPtr) {
                $calltype='matlabcall'
            }
        print OUTFILE "fcns.name{fcnNum}='$name'; ";
        $alias=MakeMatlabVar($name);
        print OUTFILE "fcns.alias{fcnNum}='$alias'; " if $alias ne $name;
        if (exists $options{thunkfile} && ($calltype ne 'matlabcall')) {
            my $thunkname=addFunctionThunk($lhs,@parameters);
            print OUTFILE "fcns.thunkname{fcnNum}='$thunkname';";
        }
                        
        print OUTFILE "fcns.calltype{fcnNum}='$calltype'; ";
        if ($lhs eq 'void') {
            print OUTFILE "fcns.LHS{fcnNum}=[]; ";
        } else {
            print OUTFILE "fcns.LHS{fcnNum}='$lhs'; ";
        }
        if (@parameters==0 || $parameters[0] eq 'void') {
            print OUTFILE "fcns.RHS{fcnNum}=[];";
        }else {
            print OUTFILE "fcns.RHS{fcnNum}={'" ,join("', '",@parameters),"'};";
        }
        print OUTFILE "fcnNum=fcnNum+1;\n";
        $functionCount++;
        print "function string was '$str'\n" if ($options{debug} eq 'functions');
        $str = "";
    } 
        #can the string be dumped?
        print "Dumping '$str'\n" if ($options{debug} && length($str)>1);
        $str="";
}
}

print "Last string was '$str'\n" if ($options{debug} && length($str)>1);

for (@structOrder) {
    if (exists $typesUsed{$_}) {
        if (!exists $structs{$_}) {
            print "warning struct $_ not found\n";
        } else {
            print OUTFILE "structs.$_.packing=$structPacking{$_};\n";
            print OUTFILE "structs.$_.members=struct('",join( "', '",@{$structs{$_}}),"');\n"; 
            $structCount++;
        }
    }
}

for (keys %enums) {
    if (exists $typesUsed{$_}) {
        print OUTFILE "enuminfo.$_=struct(" ,join(",",@{$enums{$_}}) , ");\n"; 
    }
}    
    
print OUTFILE "methodinfo=fcns;" if $writeingfunc;
#end of main function

sub OldParseParam {
    my $parameter=$_[0];
    $parameter =~ s/\s{2,}/ /g;
    # Chop off leading and trailing whitespace
    $parameter =~ s/^ //g;
    $parameter =~ s/ $//g;

    $parameter=arrayToPtr($parameter) if $parameter=~/\[|&/;

    if ($parameter =~/^(.*[ *])(\w+)$/) 
    {                
        #get rid of the variable if present
        $parameter=$1;
        $paramName=$2;
        # could be $parameter=unsigned $paramName=long
        if (exists $keywords{$paramName})
        {
            #Rebuild the parameter
            $parameter.=$paramName;     
            $paramName='';               
        }
    } else {
        $paramName='';
    }
    # fix up types that have array declarations ie int[]
    $parameter=~s/(\*+)(\w+)$/$2$1/;
    $parameter=GetUddType($parameter);
    return $parameter;
}

#clean up a type name to one that is representable in matlab as a variable name
sub MakeMatlabVar {
    $_=$_[0];
    my $rep=defined $_[1] ? $_[1] : '';
    s/^_+/$rep/;  # change leading _ they are illegal in matlab
    $_;
}
    
#create a new type basictype is the matlab type 
sub AddType {
    my $newtype=$_[0];
    my $basictype=$_[1];
    die if (!defined $newtype || !defined $basictype );
    if (exists $types{$newtype} and $types{$newtype} ne 'error') {
         DumpInfo ("Error attempt to define '$newtype' a second time.  While processing:\n$str\nCurrent defininition is '$types{$newtype}'."); 
    }
    else {
        print "Creating type '$newtype' to be '$basictype'\n" if ($options{debug} eq 'types');
        $types{$newtype} = $basictype;
    }
}


sub ParseType {
    # given an input return the MATLAB type [and name in $varName]
    my $type=$_[0];
    my $arraysize;
    undef $varName;
    #remove leading spaces and trailing [ ;]+
    $type =~ s/^\s+//;
    $type =~ s/[\s;]+$//;

    #find the name if it exists
    #pull any 'const' statments
    $type =~ s/_{0,2}const\s+//g;
    #pull any 'signed' statements
    #$type =~ s/\bsigned\b//g;
    #remove array notation first
    if ($type=~/(.*\S)\s?\[(\s?\S+.*)\]$/){
        print "Found array size $2 of type $1 in $type\n" if exists $debug{'types'};
        $type=$1;
        $arraysize=ParseConstExp($2);
    }
    $type=arrayToPtr($type) if $type=~/\[|&/;
    
    if ($type=~/^\w+$/ || $type=~/\*$/) { # simple case one word or trailing ptr
        $type=GetUddType($type);
    } elsif ($type=~/^(\w+[*\s]+)(\w+) ?$/ ){
        # 2 words
        # check to see if found name is a reserved word
        if (exists $keywords{$2} || $1=~/^(struct|enum)[*\s]+$/) {
            #Rebuild the parameter
            $type=GetUddType($type);
        } else {
            $varName= $2;
            $type=GetUddType($1);
        }
    } elsif ($type=~/^((?:signed |unsigned |short |long |enum |struct )+)(\w+[*\s]+)(\w+)$/ ){
        #three or more words includeing keyword(s)?
        $varName= $3;
        $type=GetUddType($1.$2);
        print "from '$_[0]' go type of $type p1='$1' p3='$2'\n" if exists $debug{'longtypes'};
#    } elsif ($type=~/^(unsigned)?\b(short|long)?\b(\w+[*\s]*)$/ ) {
#        $type=GetUddType($1.$2.$3);
   
    } elsif ($type =~/\)\s*$/) {  #Is the type a function prototype?
        print "found function prototype in '$type'.\n" if $options{debug};
        #try to find the name
        if ( $type =~/^[^(]*\([^)]*\b(\w+) ?\)\([^)]*\) ?$/ 
             || $type =~/^.*\b(\w+) ?\(.*\) ?$/  ) {
            $varName=$1
        } else {
            print "Failed to find variable name in $type\n"
            #$varName='Unknown';
        }
        return 'FcnPtr';
    } else {
        DumpInfo("Failed to parse type '$type' original input '$_[0]'\n");
        return undef;
    }
    $type = $type.'#'.$arraysize if defined $arraysize; 
    print "Found something named $varName in'$_[0]'\n" if (defined $varName && exists $debug{'names'});
    return $type;
     
}

sub isBalanced {
    my $t=$_[0];
    $t=~tr/{([// == $t=~tr/})]// ;
    #if (
}

sub findMatch1 {
    local $_=$_[0];
    #taken from perlfaq4
    #finds inner block and returns it
    my $B='{';
    my $E='}';
    while (s/$B((?:(?!$B)(?!$E).)*)$E//gs) {
	print "Match:$1\n"# do something with $1
    }
    print "Final string:$_\n";
}

sub splitTypes { #split types,vars or paramiters on commas
    local $_=$_[0];
    #can we do a simple split ?
    if (!/[{(]/) {
        return split ',',$_;
    }
    print "found parens in $_\n";
    findMatch1($_);
    return $_
}

sub ProcessTypedef {
    local $_;
    my $basetype=$_[0];
    my $newtype;
    my @newtypes=splitTypes($_[1]);
#    print "newtypes is '@newtypes' split from '$_[1]'\n";
    for (@newtypes) {
        my $baseType= ParseType($basetype .' '. $_);
        if (!defined $varName) {
            print "No types defined in $basetype $_\n found in:$str\n" if $options{debug};
            next;
        }
        $baseType='error' if !defined $baseType;
        if ($options{debug} && $baseType ne 'FcnPtr') {
        $_=arrayToPtr($_) if /\[/;
        if (/\*/)
        {
            if (!defined($_) or !defined($basetype) ){
                print "one of '$_' and '$basetype' was not defined\n";
                next;
            }
                
            my $type=$basetype . $_;
            #print "working string '$type'\n";
            $type =~/^(.*[* ])(\w+)\s*/;
            $newtype=$2;
            $newbase=cleanupType($1);
        }  else {
            $newtype=$_;
            $newbase=cleanupType($basetype);
        }
        #clean all whitespace 
        $newtype =~ s/\s+//g;
        if ($newtype ne $varName) {
                print "+++++ New type name of $varName does not match old name $newtype \n" ;
                print "+++++ when parseing '$_[0] $_[1]'\n" ;
        }

        $newdefinition=GetUddType($newbase);        
        if ($newdefinition ne $baseType) {
                print "**** New type of $baseType does not match old type of $newdefinition \n" ;
                print "*****when parseing $varName in '$_[0] $_[1]\n" ;
        }

        }
        next if !defined $varName;
        if (exists $types{$varName})
        {
            if (!exists $typeOverrides{$varName}) {
                if ($types{$varName} ne $baseType)  {
                    DumpError("Attempt to redefine '$baseType' current definition $types{$varName} new definition $baseType.\n"); 
                } else {
                    print "Found second identical definition of type $newtype.\n" if $options{debug} eq 'types';
                }
            }
        } else {
            AddType($varName,$baseType);
        }
        $_=$varName;
    }
    $newtypes[0];
}

sub ProcessEnum {
    my $name=$_[0];
    my $members=$_[1];
    my @ed;
    my @memb=split ',', $members;
    my $value=-1;  # start value at -1 because it is incremented before use.
    print "Found enum $name.\n" if $options{debug} eq 'enums';
    for (@memb) {
        s/\s//g; #trim all spaces
        next if ($_ eq '');
        my $enum=$_; 
        if (/^(\w+)=(.*)$/) {
            $enum=$1;
            my $newvalue=ParseConstExp($2);
            next if !defined $newvalue;
            $value=$newvalue;
            print "translated to '$value'.\n" if $options{debug} eq 'enums';
            
        } else {
            $value++;
        }
        $enumValueMap{$enum}=$value;
        $_=MakeMatlabVar($enum);
        push @ed,"'$enum',$value";
    }
    $enums{$name}=\@ed; 
    if ($inSrcFile) {
        $typesUsed{$name}=[];
    }
}

sub ParseConstExp { #one input contains exp to parse returns undef on failure
    my $inp=$_[0];
    local $_;
    #first change const vars to numeric value
    print "Parsing $inp\n" if $options{debug} eq 'constexp';
    while ($inp=~/\b[A-Za-z_]\w+\b/) {
        print "Evaluating $& value from $inp" if $options{debug} eq 'constexp';
        if (exists $enumValueMap{$&}) {
            $inp=~s/$&/$enumValueMap{$&}/;
            print "reduced to $inp\n"  if $options{debug} eq 'constexp';
        } else { 
            #some error here?  for now just remove it
            DumpInfo("\nNo match found for enum value expression $& in $inp expression ignored.");
            return -1;
       } 
    } 
    #strip trailing [uUlL] from numbers
    $inp=~s/\B[uU]//;
    $inp=~s/\B[lL]//;
    
    $_=eval($inp);
    if (!defined $_) {
        DumpInfo("Eval of const expression $inp failed with error $@.\n");
        return undef;
    }
    $_=oct($_) if $_=~/^0/;
    print "Evaluated $_[0] and found a value of $_\n" if $options{debug} eq 'constexp';
    return $_;
}
    
# mark a datatype as used by a function that will be imported
sub AddUsedType {
    $_=$_[0];
    s/Ptr//g;
    if ($options{debug} eq 'types')
    {
        print "Found use of struct $_\n" if exists $structs{$_};
        print "Found use of enum $_\n" if exists $enums{$_};
    }
    $typesUsed{$_}=[];
}

sub ParseStruct {
    $_=$_[0];  # input is the struct definition  
    #output1 is a reference to an array consisting of name,type,name,type ....
    print "Processing structure members $[0]\n" if ($options{debug} eq 'structs');
    my @memb=split ';', $_[0];
    pop @memb;  #last element is empty
    my @sd;
    my $errcount;
    for (@memb) {
        
        #need to detect function ptr types by unbalenced ( before ,
        if (/^(.*?)\b(\w+)\s?,(.*)$/) {  # if multiple vars of same type
             my $type=$1;
             if (!isBalanced($type)) {
                DumpInfo ("Function pointer types are unsupported in structures $type.\n") ;
                push @sd,('error' . $errcount++ ,'voidPtr');
                $type='voidPtr';
                next;
             }
             my $var1=MakeMatlabVar($2,'m_');
             my @othervars=split ',', $3;
             print "Found multiple struct members type=$type, var1=$var1, othervars=@othervars\n" if ($options{debug} eq 'structs');
             push @sd,$var1;
             push @sd,GetUddType($type);
             
             for (@othervars) {
                my $st=$type . ' ' .$_;
                if ($st=~/^(.*)\b(\w+)\s*$/) {
                    my $t=$1;
                    my $var=$2;
                    print "from $st Adding var $var of type $t\n" if ($options{debug} eq 'structs');
                    push @sd,(MakeMatlabVar($var,'m_'),GetUddType($t));
                } else {
                    push @sd,('error' . $errcount++ ,$_) if (!/^ ?$/);
                }
            }           
        } elsif (/^(.*)\b(\w+)\s*$/) {
            my $var=MakeMatlabVar($2,'m_');
            my $type=$1;
            push @sd,$var;
            push @sd,GetUddType($type);
        } elsif (/^(.*)\b(\w+)\s*\[(.*)]\s*$/) { #sized array
            my $var=MakeMatlabVar($2,'m_');
            my $type=$1;
            my $size=ParseConstExp($3);
            print "found sized array of $1 size $3 in structure\n " if ($options{debug} eq 'structs');
            push @sd,$var;
            push @sd,GetUddType($type).'#'.$size;
        } else {
            print "Could not parse structure member $_\n " if ($options{debug} eq 'structs');

            push @sd,('error' . $errcount++ ,$_) if (!/^ ?$/);
        }
    }
    return \@sd;
}    
 
sub ProcessStruct {
    my $cname=$_[0];
    my $sname=MakeMatlabVar($cname,'s_');
    my $members=$_[1];
    my $types=$_[2];
    my @sd;
    if ($members=~/:/) {
        DumpInfo ("Bitfields are unsupported in structures. Structure $sname skipped." );
        return;
    }
    if ($members=~/\bunion\b/) {
        DumpInfo ("Unions are unsupported in structures. Structure $sname skipped.") ;
        return;
    }
    AddType($cname,$sname) if $cname ne $sname;
    AddType($sname,$sname);
    ProcessTypedef($sname,$types);
    
   push @structOrder,$sname;
    $structs{$sname}=ParseStruct($members);
    $structPacking{$sname}=$packing; 
    if ($inSrcFile) {
        $typesUsed{$sname}=[];
    }
    #print OUTFILE "structinfo{$structCount}=struct('name','$sname','" ,join( "', '",@sd),"');\n"; 
    #$structCount++;

}

# get the udd type for a given c type
sub GetUddType{
    my $type=cleanupType($_[0]);
    if (exists $types{$type})
    {
        $type=$types{$type};
#        if ($inSrcFile && exists $structs{$type} ) {
        if ($inSrcFile  ) {
            AddUsedType($type);
        }
        
    } else { 
        #DumpError("Type '$type' was not found. A add a typedef to the header file defining it as a known type.");
        my $deftype='error';
        if ($type=~/Ptr(Ptr)?$/) {
             $deftype=defined $1 ? "voidPtr$1" : "voidPtr";
        }
        print "Type '$type' was not found on line $. defaulting to type $deftype.\n" if $options{debug};
        $type=$deftype;
    }
    $type;    
}

sub arrayToPtr{
    $_=$_[0];
    s/(\w+)\s*\[([^]]*)\]/\*$1/g;
    s/&/*/g;
    return $_;
}


# Take a c type and remove all extra information and change * to Ptr or PtrPtr
sub cleanupType{
    my $type=$_[0];
    #pull any 'const' statments
    $type =~ s/_{0,2}const//g;
    #pull any 'signed' statements
    $type =~ s/\bsigned\b//g;
    
    #pull any 'struct' statements
    $type =~ s/\bstruct\b//g;
 
    #clean all whitespace 
    $type =~ s/\s+//g;
        
    $ptr=index($type, "*");
    if ($ptr>=0) {
        $type =~ s/\*/Ptr/g; 
        if (!exists $types{$type}) { # check to see if the base type exists and if so add the Ptr type       
            $basetype=substr($type,0,$ptr); 
            if (exists $types{$basetype}  ) { #create the new type
                #create a new pointer type
                $newtype=$type;
                $newtype=~s/$basetype/$types{$basetype}/;
                print "Dynamicly adding type '$type' to be '$newtype'\n" if ($options{debug} eq 'types');
                AddType($type,$newtype); 
            } else {
                print "Type '$type' not added because could not find basetype of '$basetype'\n" if ($options{debug} eq 'types');
            }                
        }            
    }
    $type;
}


sub addFunctionThunk {
    my @params;
    my $thunkname;
    my $p;
    foreach (@_) {
        $_='voidPtr' if /Ptr/;
        $_='int' if !exists $MatlabType{$_};
    }
    $thunkname=join("",@_) . 'Thunk';
    if (exists $thunkTable{$thunkname}) {
        return $thunkname;
    }
    $thunkTable{$thunkname}=undef;
    my ($lhs,@rhs)=@_;
    print THUNKFILE "$lhs $thunkname(void fcn(),const char *callstack,int stacksize)\n{\n";
    if (@rhs==1 && $rhs[0] eq 'void') {
        @params=();
    } else {
        $p=0;
        foreach (@rhs) {
            print THUNKFILE "\t$_ p$p;\n";
            push @params,"p$p";
            $p+=1;
        }
        $p=0;
        foreach (@rhs) {
            print THUNKFILE "\tp$p=*(const $_*)callstack;\n";
            print THUNKFILE "\tcallstack+=sizeof(p$p);\n";
            $p+=1;
        }
    }
    if ($lhs eq 'void') {
        print THUNKFILE "\t(($lhs (*)(", join(" , ",@rhs) ," ))fcn)(",join(" , ",@params),");\n}\n\n";
    } else {
        print THUNKFILE "\treturn (($lhs (*)(", join(" , ",@rhs) ," ))fcn)(",join(" , ",@params),");\n}\n\n";
    }
    return $thunkname;
}

sub DumpInfo{
    print "@_\n";
    my $line=$.-$srcLine-1;
    print "Found on line $. of input from line $line of file $srcFile\n\n";
}

sub DumpError{
    DumpInfo( "ERROR: @_");
    die "Working string is '$str'.\n";
}



sub parsArgs
{
%options=@_; #qw(s 1 d 0 m 0 r 0 a 0 l 1 e path);
my @inputs;
#parse the input for options
while (@ARGV) {
	$_=shift @ARGV;
	if (/^-(\w+)/) { 
		my $opt=$1;
		#now look for special opts
		if (/-debug=/) {
		  $debug{$'}=1;
		  $options{'debug'}=$'; #for compatiblity  
		} elsif (/-\w+=/) { #options that store there own string
		        #print "found string option '$opt' in '$_'.\n";
			$options{$opt}=$';
		} elsif (/-\w+-/) { #disable opt
			$options{$opt}=0;
		} elsif (/-\w+\+/) {
			$options{$opt}=1;
		} else { $options{$opt}=!$options{$opt};}
		print "option $opt is now $options{$opt}\n" if ($options{debug});
				
	} else {
		push (@inputs,$_);
	}
}
#put ARGV back
@ARGV=@inputs;
}
